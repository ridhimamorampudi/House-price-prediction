import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

#Data set
from sklearn.datasets import fetch_california_housing
#get the data
data = fetch_california_housing()

print(data.DESCR)

#data frame is 2d matrix#all independent data
df = pd.DataFrame(data = data.data, columns = data.feature_names)
#fetches first 5 rows
df.head()

#dependent data
df['Target'] = data.target
df.head()

#exploratory data analysis EDA
#when 2 features are correlated we cna discard it
import sweetviz as sv

report = sv.analyze(df)
report.show_html("./report.html")

#Data pre-processing
from geopy.geocoders import Nomination
geolocator = Nomination(user_agent = 'geoapiExercises')
#user agent is an api so when you pass latitude and longitde ot goes into web and passes the reuslt

#geolocator.reverse("37.88" + "," + "-122.23").raw['address'] without address shows all
def location(coord):
    Latitude = str(coord[0])
    Longitude = str(coord[1])

    location = geolocator.reverse(Latitude + "," + Longitude).raw['address'] #raw returns a dict
    #if the values are missing replace by empty string

    if location.get('Road') is None:
        location['Road'] = None

    if location.get('County') is None:
        location['road'] = None  
    loc_update['County'].append(location['County'])
    loc_update['Road'].append(location['Road'])

    loc_update = {"County":[],
                  "Road":[],
                  "Neighborhood":[]}
    
    # for i,cord in enumerate(df.ilock[:,6:-1].values):
    #     location(cord)
    #     #continuously reading our data and saving it on the go
    #     pickle.dump(loc_update,open('loc_update.pickle','wb'))

    #     if i%100==0:
    #         print(1)

    #to load pickle module
import pickle
loc_update = pickle.load(open("loc_update.pickle","rb"))

#add data back to dataframe
loc = pd.DataFrame(loc_update)
loc.info()

#add new features to daatframe
for i in loc_update.keys():
    #entire row
    df[i] = loc_update[i] 
#shuffled data
df = df.sample(axis=0,frac=1)
df.head()

df.drop(labels=["Latitude","Longitude","Neighborhood"],axis=1)
df.head()

df.info()

#use min or max value and repeat or use logistic regression
#missing data is test data and other is traiing data

#using Classification to fill missing categorical values
missing_idx = []

for i in range(df.shape[0]):
    if df['Road'][i] is None:
        missing_idx.append(i)

#independent parameters
missing_Road_X_train = np.array([ [df['MedInc'][i],df['AveRooms'][i],df['AveBedrms'][i]] for i in range(df.shape[0]) if i not in missing_idx])

#Dependent parameter
missing_Road_y_train = np.array([ df['Road'][i] for i in range(df.shape[0]) if i not in missing_idx])

missing_Road_X_test = np.array([ [df['MedInc'][i],df['AveRooms'][i],df['AveBedrms'][i]] for i in range(df.shape[0]) if i in missing_idx])

from sklearn.linear_model import SGDClassifier

#model initialization
model_1 = SGDClassifier()

#Model Training
model_1.fit(missing_Road_X_train,missing_Road_y_train)

missing_Road_y_pred = model_1.predict(missing_Road_X_test)
np.unique(missing_Road_y_pred)

#add the model back to dataframe
for n,i in enumerate(missing_idx):
    df['Road'][i] = missing_Road_y_pred[n]

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
df['Road'] = le.fit_transform(df['Road'])  

#Predicting County
missing_idx = []

for i in range(df.shape[0]):
    if df['County'][i] is None:
        missing_idx.append(i)

#independent parameters
missing_County_X_train = np.array([ [df['MedInc'][i],df['AveRooms'][i],df['AveBedrms'][i]] for i in range(df.shape[0]) if i not in missing_idx])

#Dependent parameter
missing_County_y_train = np.array([ df['County'][i] for i in range(df.shape[0]) if i not in missing_idx])

missing_County_X_test = np.array([ [df['MedInc'][i],df['AveRooms'][i],df['AveBedrms'][i]] for i in range(df.shape[0]) if i in missing_idx])

from sklearn.linear_model import SGDClassifier

#model initialization
model_1 = SGDClassifier()

#Model Training
model_1.fit(missing_County_X_train,missing_County_y_train)

missing_County_y_pred = model_1.predict(missing_County_X_test)
np.unique(missing_County_y_pred)

#add the model back to dataframe
for n,i in enumerate(missing_idx):
    df['County'][i] = missing_County_y_pred[n]

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
df['County'] = le.fit_transform(df['County']) 

df.info() 






